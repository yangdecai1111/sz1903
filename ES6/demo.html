<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <!--<script type="text/javascript" src="javascript/Ajax.js"></script>-->
    <script type="text/javascript">
        /**您现在看到的是由千锋H5教学部为您录制的教学视频。
         *
         * 今天要给大家介绍的是：ES6
         * ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。
         * 它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。
         *
         * 1、ECMAScript和JavaScript的关系
         * 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，
         * 决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。
         * 次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，
         * 并将这种语言称为ECMAScript，这个版本就是1.0版。
         * 该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。
         * 一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，
         * 且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。
         * 因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。
         * 日常场合，这两个词是可以互换的。
         *
         * 2、ES6与ECMAScript 2015的关系
         * 媒体里面经常可以看到”ECMAScript 2015“这个词，它与ES6是什么关系呢？
         * 2011年，ECMAScript 5.1版发布后，就开始制定6.0版了。因此，”ES6”这个词的原意，就是指JavaScript语言的下一个版本。
         * 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。
         * 事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布6.0版，过一段时间再发6.1版，然后是6.2版、6.3版等等。
         * 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，
         * 然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。
         * 这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。
         * 标准委员会最终决定，标准在每年的6月份正式发布一次，作为当年的正式版本。
         * 接下来的时间，就在这个版本的基础上做改动，直到下一年的6月份，草案就自然变成了新一年的版本。
         * 这样一来，就不需要以前的版本号了，只要用年份标记就可以了。
         * ES6的第一个版本，就这样在2015年6月发布了，正式名称就是《ECMAScript 2015标准》（简称ES2015）。
         * 2016年6月，小幅修订的《ECMAScript 2016标准》（简称ES2016）如期发布，这个版本可以看作是ES6.1版，
         * 因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017年6月将发布ES2017标准。
         * 因此，ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，
         * 而ES2015则是正式名称，特指该年发布的正式版本的语言标准。
         *
         * 3、语法提案的批准流程
         * 任何人都可以向TC39标准委员会提案。一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC39委员会批准。
         * Stage 0 - Strawman（展示阶段）
         * Stage 1 - Proposal（征求意见阶段）
         * Stage 2 - Draft（草案阶段）
         * Stage 3 - Candidate（候选人阶段）
         * Stage 4 - Finished（定案阶段）
         * 一个提案只要能进入Stage 2，就差不多等于肯定会包括在以后的正式标准里面。
         * ECMAScript当前的所有提案，可以在TC39的官方网站Github.com/tc39/ecma262查看。
         */


        /**
         * 因为目前很多浏览器对es6支持的相对不高。所以我们在实际的开发过程中需要将es6转换称低版本的javascript代码。
         * 下面我们给大家单独介绍一下编译es6代码的工具：Babel
         */


        /**
         * 由于ES6加入的东西实在太多，简直是一言不合就加API。ES6新增的知识量，堪比ES3的内容总和了。
         * 但并不都是非常有用的，当然也可能是还没发现它哪里有用 目前浏览器的支持还处于初级阶段，
         * 我们还是要学会自己去思考和辨识。 所以本文中的内容没有必要全部都讲，实用优先。
         */


        /**
         * 关键字：let
         * 介绍：我们都知道var的作用是申明变量用的，同样let关键字也是申明变量用的。
         *
         * 需求：在程序的设计过程中，需要申明一个块级作用域，形成作用域的封闭区。
         * 说明：
         * 变量的块级作用域：就是某个变量在某一个代码块中有效，代码块可以理解为是以大括号为界限的。
         * 然后在这个代码块内不能重复申明同名的变量，这个现象就形成了变量作用域的封闭区。
         * 实现代码如下：
         */
        function main(){
//            var i=0;
//            var i=1;
//            console.log(i);//控制台输出的结果是：1
//            //以上的代码在同一个代码块中是可以多次申明同名变量的。
//            //弊端：变量名混乱，打个比方如果我们班的所有学生都叫小明，那么我现在叫小明：请问哪位同学会理我。
//
//            //对比：var 和 let
//            let n=0;//在此处申明变量，同时也就限定了该代码块内不能再申明同名的变量，这样就形成了作用域的封闭区；
//            //let n=1;//'n' has already been declared
//            //在同一个区间内不允许申明相同名称的变量




            //块级作用域：
//            console.log(a);
//            for(var a=0;a<10;a++){//变量提升到最顶端。远远跳出了for循环；
//
//            }
//            console.log(a);//输出10，也就是说出了for循环后a的作用域还是依然存在的，这样会导致变量不能被回收，依然会污染函数代码块内的作用域

            //对比：var 和 let
            //console.log(m);//报错: m is not defined, let声明的变量m没有提升；
//            for(let m=0;m<10;m++){
//                console.log(m);
//            }
            //console.log(m);//报错：m is not defined 说明变量跳出for循环的代码块是无效的。这个地方就验证了块级作用域。




//            //下面我们试一下let关键字申明的变量
//            let n=0;
//            //let n=1;//这里是不允许变量重复申明的，避免了变量重名，导致的错误
//            //提示n has already been declared
//            for(let m=0;m<10;m++){
//                let m=100;
//                //let m=10;//在同一个大括号内不允许申明相同名称的变量，这个代码块区间就是作用域的封闭区
//                console.log(m);
//            }
//            console.log(m);//m is not defined
//            let m=1000;//for循环代码块的作用域不能影响到这里，所以let关键字有块级作用域，就是某个代码块有效。
//            //let 申明的变量也没有提升！！
//            console.log(m);
        }

//        "use strict";
//        function m() {
//            console.log("111111111");
//        }
//        if( 6 > 5) {
//            function m() {
//                console.log("2222222222")
//            }
//        }
//        m();//2222222222


        /**
         * const：
         * 作用：申明一个常量
         * 常量：设定完以后不能被修改的变量称为常量，因为这边量不能被修改，所以它是常态化的，所以称之为常量
         *
         * 需求：我要申明一个变量，申明并初始化之后不能被修改；
         * 代码：
         */
//        function main(){
//            let pi=3.141;
//
//            pi=3.9;//我在这个地方不小心修改了，在一下的程序当中进行数学运算的时候，pi还能否代表圆周率了？
//            //所以我们需要一个约束我们粗心的方法，来限制我们不出错。或者说错了要提示我们。那在这里就要使用：
//            //const
//            const p=3.14;
//            //p=3;//当变量被申明为常量后，是不允许被修改的。
//
//            const n;
//            n=0;
//            //申明常量的时候一定要初始化。申明并且初始化要同步进行，不允许先申明变量名，然后在赋值；
//
//            //const同let相似，一样会产生块级作用域，和作用域的封闭区。
//
//            //定义常量的时候，很多人程序员喜欢大写，好区分。没有必须约束，只是一个习惯
//        }


        /**
         * 箭头函数：=>
         * 跟以往的函数相比较的话，箭头函数很大程度上类似与我们的匿名函数
         * 最早我接触的箭头函数源与C#。
         *
         * 箭头函数的性质：兼函数与表达式两种性质
         */
        function main() {
//            var _value = (function () {
//                return 10;
//            })();
//            console.log(_value);
//
//
//
//
//            var _arrow=((a)=>{
//                return a;
//            })(10);
//            console.log(_arrow);
//
//
//
//            var _test=((a,b)=>a+b)(10,100);
//            console.log(_test);

            //使用箭头函数的好处：this指向


//            var _obj={
//                "name":"test",
//                "attr":"attr"
//            };
//            _obj.fx=function(){
//                var x=()=>{
//                    console.log(this);//this:指向_obj所指向的对象
//                }
//                x();
//                var y=function(){
//                    console.log(this);//this:指向window；
//                }
//                y();
//                //证明箭头函数是兼函数与表达式两种特性；
//            }
//            _obj.fx();

            /**
             * 箭头函数返回一个json格式的对象
             * 第一：有特殊性因为json格式对象是以大括号开头的。
             *
             */
//            var _json=()=>{
//                return {
//                    "key1":"value1"
//                }
//            }
//            console.log(_json());

//            var _json=()=>{
//                "key1":"value1"
//            }
//            function fx(){
//                "key":"value1"
//            }//很显然这个地方不符合我们代码书写规范
//            console.log(_json);
            //解决方法：
//            var _json=()=>({
//                "key1":"value1"
//            });
//            console.log(_json());

            /**
             * 普及一下表达式的概念：
             * 2+3 : 这是一个数学表达式
             * 2 ：是不是一个表达式？答案：no
             * (2) ：是不是一个表达式？答案：yes
             * (2+3)*5 ：带来的问题是？小括号有没有参与运算？如果有，小括号是不是一个云算符号；
             * 小括号改变了整个表达式的四则运算的顺序，所以小括号参与运算了，那么就确定小括号是一个运算符
             * 同样在编程语言中小括号也是可以改变表达式的运算顺序的；
             * 表达式是不常驻内存的，运行计算完毕后就会被释放内存；
             */
//            var _json=()=>({
//                "key1":"value1"
//            });
//            ()=>5+5;
//            ()=>10;
//            ()=>({
//                var a=10;
//                var b=100;
//                return a+b;
//            });
//            ()=>(2+3 3+2)
//            2+3;
//            console.log(_json());

            /**
             * 箭头函数不能使用 new 关键字调用
             */
//            var _person=new (()=>{
//                this.sex="male";
//                this.tall="180cm";
//                this.age="10";
//            })();
//            var _person=new (function(){
//                this.sex="male";
//                this.tall="180cm";
//                this.age="10";
//            })();
//            var Arrow=()=>{
//                this.sex="male";
//                this.tall="180cm";
//                this.age="10";
//            }
//            var _person=new Arrow();//报错：Arrow is not constructor
//            console.log(_person);
//
//            var Arrow=function(){
//                this.sex="male";
//                this.tall="180cm";
//                this.age="10";
//            }
//            var _person=new Arrow();//正确
//            console.log(_person);
        }


        /**
         * Map对象：
         * ES5中我们学过数组的map方法，跟这里的Map对象是完全不同的。
         *
         * 第一：Map对象申明
         * 第二：Map对象设置项
         * 第三：Map对象取值
         * 第四：Map对象遍历
         *
         * 注：Map对象中不能出现绝对相等的多个key，如果存在，最后添加进去的同名的key会覆盖前面同名的key所对应的值；
         */
//        function main(){
//            var _map=new Map();
//            _map.set("key1","value1");
//            _map.set("key2","value2");
//            _map.set("key3","value3");
//            _map.set("key4","value4");
//            _map.set("key1","value5");
//            console.log(_map.keys());
//            //keys()方法的返回值的数据类型：MapIterator称之为迭代器。
//            //返回值：{"key1", "key2", "key3", "key4"}
//            console.log(_map.get("key1"));//value5
//
//            //遍历key
//            for(let key of _map.keys()){
//                console.log(key);
//            }
//            for(let value of _map.values()){
//                console.log(value);
//            }
//            for(let key of _map.keys()){
//                console.log(_map.get(key));
//            }
//            //扩展一下
//            console.log(_map.entries());
//            //entries()方法的返回值的数据类型：MapIterator称之为迭代器。
//            // 返回值：{["key1", "value5"], ["key2", "value2"], ["key3", "value3"], ["key4", "value4"]}
//            for(let entry of _map.entries()){
//                console.log(entry[0],entry[1]);
//            }

//            var _map1=new Map();
//            _map.set("key1","value1");
//            _map.set("key2","value2");
//            _map.set("key3","value3");
//            _map.set("key4","value4");
//            _map.set("key1","value5");
//
//            var _map2=new Map();
//            _map.set("key1","value9");
//            _map.set("key2","value8");
//            _map.set("key3","value3");
//            _map.set("key4","value4");
//            _map.set("key1","value5");
//        }

        /**
         * Set对象：
         * 如何使用？
         * 第一：Set对象申明
         * 第二：Set对象添加项
         * 第三：Set对象取值
         * 第四：遍历
         *
         * 与Map对象的区别：没有键。都称之为数据集合；
         */
//        function main(){
//            var _set=new Set();
//            _set.add("value1");
//            _set.add("value2");
//            _set.add("value3");
//            _set.add("value4");
//            console.log(_set.keys());//返回值数据类型SetIterator，返回值：{"value1", "value2", "value3", "value4"}
//            console.log(_set.values());//返回值数据类型SetIterator，返回值：{"value1", "value2", "value3", "value4"}
//            //遍历
//            for(let val of _set.values()){
//                console.log(val);
//            }
//            //获取单个元素
//            console.log(_set.values().next().value);
//
//            //next()返回值：
//            console.log(_set.values().next());//Object {value: "value1", done: false}
//
//            let imgs = new Set();
//            imgs.add(1);
//            imgs.add(1);
//            imgs.add(5);
//            imgs.add("5");
//            imgs.add(new String("abc"));
//            imgs.add(new String("abc"));
//
//            //var newarr = [...new Set(array)]; 利用Set对象的特性，可以巧妙的进行数组去重
//            var _arr=[1,1,3,4,3,4,5,6];
//            var _newArr=[...new Set(_arr)];
//            console.log(_newArr);
//        }




        window.onload=function(){
            main();
        }
    </script>
</head>
<body>

</body>
</html>